<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RBC Color Analysis Tool</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .analysis-section {
            margin: 20px 0;
            padding: 15px;
            border-left: 4px solid #007bff;
            background-color: #f8f9fa;
        }
        canvas {
            border: 2px solid #ccc;
            margin: 10px;
            border-radius: 5px;
        }
        .color-info {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin: 15px 0;
        }
        .color-box {
            width: 40px;
            height: 40px;
            border: 2px solid #333;
            border-radius: 5px;
            display: inline-block;
        }
        .stats-table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }
        .stats-table th, .stats-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        .stats-table th {
            background-color: #f2f2f2;
        }
        .confidence-bar {
            background-color: #e0e0e0;
            height: 20px;
            border-radius: 10px;
            overflow: hidden;
            margin: 5px 0;
        }
        .confidence-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b, #feca57, #48dbfb, #0abde3);
            transition: width 0.3s ease;
        }
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px 5px;
        }
        button:hover {
            background-color: #0056b3;
        }
        .warning {
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üî¨ RBC Color Analysis Tool</h1>
        
        <div class="warning">
            <strong>‚ö†Ô∏è Instructions:</strong> Upload your microscopy image. The tool will automatically detect the circular field and analyze only the RBCs within that boundary.
        </div>

        <input type="file" id="imageInput" accept="image/*" style="margin: 20px 0;">
        <button onclick="analyzeImage()">üîç Analyze RBC Colors</button>
        <button onclick="downloadResults()">üìä Download Analysis Report</button>

        <div id="canvasContainer" style="display: none;">
            <h3>Image Analysis</h3>
            <canvas id="originalCanvas"></canvas>
            <canvas id="maskCanvas"></canvas>
            <canvas id="analyzedCanvas"></canvas>
        </div>

        <div id="resultsContainer" style="display: none;">
            <div class="analysis-section">
                <h3>üé® Color Analysis Results</h3>
                <div id="colorResults"></div>
            </div>

            <div class="analysis-section">
                <h3>üß™ Stain Identification</h3>
                <div id="stainResults"></div>
            </div>

            <div class="analysis-section">
                <h3>üìä Statistical Analysis</h3>
                <div id="statisticalResults"></div>
            </div>
        </div>
    </div>

    <script>
        let imageData = null;
        let analysisResults = null;

            // Stain database with RGB ranges and confidence factors
        const stainDatabase = {
            "Methylene Blue": {
                rgb_range: {r: [50, 150], g: [80, 180], b: [150, 255]},
                description: "Basic dye that stains nucleic acids and cytoplasm blue",
                expected_color: "Blue"
            },
            "Trypan Blue": {
                rgb_range: {r: [40, 120], g: [60, 160], b: [120, 220]},
                description: "Vital stain used to assess cell viability",
                expected_color: "Blue"
            },
            "Crystal Violet": {
                rgb_range: {r: [80, 160], g: [40, 120], b: [120, 200]},
                description: "Basic dye with purple-blue coloration",
                expected_color: "Purple"
            },
            "Toluidine Blue": {
                rgb_range: {r: [60, 140], g: [80, 170], b: [140, 240]},
                description: "Metachromatic dye, appears blue on most structures",
                expected_color: "Blue"
            },
            "Congo Red": {
                rgb_range: {r: [180, 255], g: [50, 150], b: [50, 150]},
                description: "Red dye used for amyloid detection",
                expected_color: "Red"
            },
            "Eosin": {
                rgb_range: {r: [200, 255], g: [100, 180], b: [150, 220]},
                description: "Pink acidic dye, counterstain in H&E",
                expected_color: "Red"
            },
            "Malachite Green": {
                rgb_range: {r: [50, 150], g: [150, 255], b: [50, 180]},
                description: "Green basic dye used in spore staining",
                expected_color: "Green"
            },
            "Neutral Red": {
                rgb_range: {r: [180, 255], g: [80, 160], b: [80, 160]},
                description: "Red vital stain for lysosomes",
                expected_color: "Red"
            },
            "Safranin": {
                rgb_range: {r: [200, 255], g: [100, 180], b: [100, 180]},
                description: "Red counterstain in Gram staining",
                expected_color: "Red"
            },
            "Fast Green": {
                rgb_range: {r: [50, 150], g: [150, 255], b: [100, 200]},
                description: "Green counterstain in trichrome staining",
                expected_color: "Green"
            },
            "Giemsa Stain": {
                rgb_range: {r: [100, 180], g: [80, 160], b: [150, 230]},
                description: "Romanowsky-type stain for blood smears, stains RBCs pink-red, nuclei blue",
                expected_color: "Purple"
            },
            "Wright's Stain": {
                rgb_range: {r: [120, 200], g: [80, 160], b: [140, 220]},
                description: "Romanowsky stain for blood cells, RBCs appear pink-orange",
                expected_color: "Red"
            },
            "Leishman Stain": {
                rgb_range: {r: [110, 190], g: [70, 150], b: [130, 210]},
                description: "Romanowsky stain similar to Wright's, for blood and bone marrow",
                expected_color: "Purple"
            },
            "Hematoxylin & Eosin (H&E)": {
                rgb_range: {r: [180, 240], g: [120, 180], b: [140, 200]},
                description: "Most common histological stain, nuclei blue, cytoplasm pink",
                expected_color: "Red"
            },
            "Gram Stain": {
                rgb_range: {r: [100, 180], g: [50, 130], b: [120, 200]},
                description: "Bacterial stain, Gram+ appears purple, Gram- appears pink/red",
                expected_color: "Purple"
            },
            "Safranin (Gram Counterstain)": {
                rgb_range: {r: [200, 255], g: [100, 180], b: [100, 180]},
                description: "Red counterstain in Gram staining for Gram-negative bacteria",
                expected_color: "Red"
            }
        };

        function detectCircularBoundary(imageData) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = imageData.width;
            canvas.height = imageData.height;
            
            // Convert to grayscale and find edges
            const grayData = new Uint8ClampedArray(imageData.width * imageData.height);
            for (let i = 0; i < imageData.data.length; i += 4) {
                const gray = 0.299 * imageData.data[i] + 0.587 * imageData.data[i + 1] + 0.114 * imageData.data[i + 2];
                grayData[i / 4] = gray;
            }

            // Simple circle detection - find the largest dark circular boundary
            const centerX = imageData.width / 2;
            const centerY = imageData.height / 2;
            const maxRadius = Math.min(imageData.width, imageData.height) / 2 - 10;

            // Return detected circle parameters
            return {
                centerX: centerX,
                centerY: centerY,
                radius: maxRadius * 0.9 // Slightly smaller to avoid edge artifacts
            };
        }

        function isInsideCircle(x, y, circle) {
            const dx = x - circle.centerX;
            const dy = y - circle.centerY;
            return (dx * dx + dy * dy) <= (circle.radius * circle.radius);
        }

        function analyzeRGBColors(imageData, circle) {
            const colors = [];
            const data = imageData.data;
            
            for (let y = 0; y < imageData.height; y++) {
                for (let x = 0; x < imageData.width; x++) {
                    if (isInsideCircle(x, y, circle)) {
                        const idx = (y * imageData.width + x) * 4;
                        const r = data[idx];
                        const g = data[idx + 1];
                        const b = data[idx + 2];
                        
                        // Filter out very light/white background pixels
                        if (r + g + b < 600) {
                            colors.push({r, g, b});
                        }
                    }
                }
            }
            
            return colors;
        }

        function calculateColorStatistics(colors) {
            if (colors.length === 0) return null;

            const stats = {
                total_pixels: colors.length,
                avg_rgb: {r: 0, g: 0, b: 0},
                median_rgb: {r: 0, g: 0, b: 0},
                std_rgb: {r: 0, g: 0, b: 0},
                dominant_colors: [],
                cell_color_name: "",
                saturation_avg: 0,
                hue_distribution: {}
            };

            // Calculate averages
            let totalR = 0, totalG = 0, totalB = 0;
            for (const color of colors) {
                totalR += color.r;
                totalG += color.g;
                totalB += color.b;
            }
            
            stats.avg_rgb.r = totalR / colors.length;
            stats.avg_rgb.g = totalG / colors.length;
            stats.avg_rgb.b = totalB / colors.length;

            // Determine actual cell color name
            stats.cell_color_name = determineColorName(stats.avg_rgb);
            
            let totalSaturation = 0;
            
            for (const color of colors) {
                // Calculate HSV saturation
                const max = Math.max(color.r, color.g, color.b);
                const min = Math.min(color.r, color.g, color.b);
                const saturation = max === 0 ? 0 : (max - min) / max;
                totalSaturation += saturation;
            }

            stats.saturation_avg = totalSaturation / colors.length;

            // Sort colors by RGB and find median
            const sortedR = colors.map(c => c.r).sort((a, b) => a - b);
            const sortedG = colors.map(c => c.g).sort((a, b) => a - b);
            const sortedB = colors.map(c => c.b).sort((a, b) => a - b);
            
            const midIdx = Math.floor(colors.length / 2);
            stats.median_rgb.r = sortedR[midIdx];
            stats.median_rgb.g = sortedG[midIdx];
            stats.median_rgb.b = sortedB[midIdx];
            return stats;
        }

        function determineColorName(rgb) {
            const r = rgb.r;
            const g = rgb.g;
            const b = rgb.b;
            
            // Find the dominant channel
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            const diff = max - min;
            
            // If very low saturation, it's grayish
            if (diff < 30) {
                if (max < 80) return "Dark Gray";
                if (max < 160) return "Gray";
                return "Light Gray";
            }
            
            // Determine hue-based color
            if (r >= g && r >= b) {
                if (g > b + 20) return "Orange";
                if (b > g + 20) return "Magenta";
                return "Red";
            } else if (g >= r && g >= b) {
                if (r > b + 20) return "Yellow";
                if (b > r + 20) return "Cyan";
                return "Green";
            } else { // b is dominant
                if (r > g + 20) return "Purple";
                if (g > r + 20) return "Teal";
                return "Blue";
            }
        }

        function identifyStain(colorStats) {
            const stainConfidences = {};
            const detectedColor = colorStats.cell_color_name;
            
            for (const [stainName, stainData] of Object.entries(stainDatabase)) {
                let confidence = 0;
                
                // Check if average RGB falls within stain range
                const avgR = colorStats.avg_rgb.r;
                const avgG = colorStats.avg_rgb.g;
                const avgB = colorStats.avg_rgb.b;
                
                const rMatch = avgR >= stainData.rgb_range.r[0] && avgR <= stainData.rgb_range.r[1];
                const gMatch = avgG >= stainData.rgb_range.g[0] && avgG <= stainData.rgb_range.g[1];
                const bMatch = avgB >= stainData.rgb_range.b[0] && avgB <= stainData.rgb_range.b[1];
                
                // Base RGB range match
                if (rMatch && gMatch && bMatch) {
                    confidence += 0.5;
                }
                
                // Color name match bonus
                if (stainData.expected_color === detectedColor) {
                    confidence += 0.3;
                }
                
                // Saturation factor - higher saturation = more confident
                confidence += colorStats.saturation_avg * 0.2;
                
                stainConfidences[stainName] = Math.min(confidence, 1.0);
            }
            
            return stainConfidences;
        }

        function analyzeImage() {
            const input = document.getElementById('imageInput');
            if (!input.files[0]) {
                alert('Please select an image first!');
                return;
            }

            const file = input.files[0];
            const img = new Image();
            
            img.onload = function() {
                // Setup canvases
                const originalCanvas = document.getElementById('originalCanvas');
                const maskCanvas = document.getElementById('maskCanvas');
                const analyzedCanvas = document.getElementById('analyzedCanvas');
                
                [originalCanvas, maskCanvas, analyzedCanvas].forEach(canvas => {
                    canvas.width = img.width;
                    canvas.height = img.height;
                });

                // Draw original image
                const originalCtx = originalCanvas.getContext('2d');
                originalCtx.drawImage(img, 0, 0);
                imageData = originalCtx.getImageData(0, 0, img.width, img.height);

                // Detect circular boundary
                const circle = detectCircularBoundary(imageData);

                // Draw mask showing analysis area
                const maskCtx = maskCanvas.getContext('2d');
                maskCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                maskCtx.fillRect(0, 0, img.width, img.height);
                maskCtx.globalCompositeOperation = 'destination-out';
                maskCtx.beginPath();
                maskCtx.arc(circle.centerX, circle.centerY, circle.radius, 0, 2 * Math.PI);
                maskCtx.fill();

                // Analyze colors within circle
                const colors = analyzeRGBColors(imageData, circle);
                const colorStats = calculateColorStatistics(colors);
                const stainConfidences = identifyStain(colorStats);

                // Draw analyzed image with highlights
                const analyzedCtx = analyzedCanvas.getContext('2d');
                analyzedCtx.drawImage(img, 0, 0);
                analyzedCtx.strokeStyle = 'red';
                analyzedCtx.lineWidth = 3;
                analyzedCtx.beginPath();
                analyzedCtx.arc(circle.centerX, circle.centerY, circle.radius, 0, 2 * Math.PI);
                analyzedCtx.stroke();

                // Store results
                analysisResults = {
                    circle: circle,
                    colors: colors,
                    colorStats: colorStats,
                    stainConfidences: stainConfidences
                };

                // Display results
                displayResults();
                document.getElementById('canvasContainer').style.display = 'block';
                document.getElementById('resultsContainer').style.display = 'block';
            };

            img.src = URL.createObjectURL(file);
        }

        function displayResults() {
            const { colorStats, stainConfidences } = analysisResults;

            // Display color results
            const colorResultsDiv = document.getElementById('colorResults');
            colorResultsDiv.innerHTML = `
                <div class="color-info">
                    <div>
                        <strong>Average RGB:</strong><br>
                        <div class="color-box" style="background-color: rgb(${Math.round(colorStats.avg_rgb.r)}, ${Math.round(colorStats.avg_rgb.g)}, ${Math.round(colorStats.avg_rgb.b)});"></div>
                        R: ${Math.round(colorStats.avg_rgb.r)}, G: ${Math.round(colorStats.avg_rgb.g)}, B: ${Math.round(colorStats.avg_rgb.b)}
                    </div>
                    <div>
                        <strong>Median RGB:</strong><br>
                        <div class="color-box" style="background-color: rgb(${colorStats.median_rgb.r}, ${colorStats.median_rgb.g}, ${colorStats.median_rgb.b});"></div>
                        R: ${colorStats.median_rgb.r}, G: ${colorStats.median_rgb.g}, B: ${colorStats.median_rgb.b}
                    </div>
                </div>
                <p><strong>Cell Color:</strong> ${colorStats.cell_color_name}</p>
                <p><strong>Average Saturation:</strong> ${(colorStats.saturation_avg * 100).toFixed(1)}%</p>
                <p><strong>Total RBC Pixels Analyzed:</strong> ${colorStats.total_pixels.toLocaleString()}</p>
            `;

            // Display stain results
            const stainResultsDiv = document.getElementById('stainResults');
            const sortedStains = Object.entries(stainConfidences).sort((a, b) => b[1] - a[1]);
            
            let stainHTML = '';
            for (const [stainName, confidence] of sortedStains) {
                const confidencePercent = (confidence * 100).toFixed(1);
                stainHTML += `
                    <div style="margin: 15px 0;">
                        <strong>${stainName}</strong> - ${confidencePercent}% confidence
                        <div class="confidence-bar">
                            <div class="confidence-fill" style="width: ${confidencePercent}%;"></div>
                        </div>
                        <p style="font-size: 14px; color: #666;">${stainDatabase[stainName].description}</p>
                    </div>
                `;
            }
            stainResultsDiv.innerHTML = stainHTML;

            // Display statistical results
            const statsDiv = document.getElementById('statisticalResults');
            statsDiv.innerHTML = `
                <table class="stats-table">
                    <tr><th>Metric</th><th>Value</th><th>Interpretation</th></tr>
                    <tr>
                        <td>Cell Color</td>
                        <td>${colorStats.cell_color_name}</td>
                        <td>Detected dominant color of the cells</td>
                    </tr>
                    <tr>
                        <td>Color Saturation</td>
                        <td>${(colorStats.saturation_avg * 100).toFixed(1)}%</td>
                        <td>${colorStats.saturation_avg > 0.5 ? 'High color intensity' : colorStats.saturation_avg > 0.3 ? 'Moderate color intensity' : 'Low color intensity'}</td>
                    </tr>
                    <tr>
                        <td>Most Likely Stain</td>
                        <td>${sortedStains[0][0]}</td>
                        <td>${(sortedStains[0][1] * 100).toFixed(1)}% confidence</td>
                    </tr>
                </table>
            `;
        }

        function downloadResults() {
            if (!analysisResults) {
                alert('Please analyze an image first!');
                return;
            }

            const { colorStats, stainConfidences } = analysisResults;
            const sortedStains = Object.entries(stainConfidences).sort((a, b) => b[1] - a[1]);
            
            const report = `
RBC Color Analysis Report
========================
Generated: ${new Date().toLocaleString()}

COLOR ANALYSIS:
- Average RGB: R:${Math.round(colorStats.avg_rgb.r)}, G:${Math.round(colorStats.avg_rgb.g)}, B:${Math.round(colorStats.avg_rgb.b)}
- Median RGB: R:${colorStats.median_rgb.r}, G:${colorStats.median_rgb.g}, B:${colorStats.median_rgb.b}
- Cell Color: ${colorStats.cell_color_name}
- Average Saturation: ${(colorStats.saturation_avg * 100).toFixed(1)}%
- Total Pixels Analyzed: ${colorStats.total_pixels.toLocaleString()}

STAIN IDENTIFICATION:
${sortedStains.map(([name, conf]) => `- ${name}: ${(conf * 100).toFixed(1)}% confidence`).join('\n')}

MOST LIKELY STAIN: ${sortedStains[0][0]} (${(sortedStains[0][1] * 100).toFixed(1)}% confidence)

RECOMMENDATION:
${sortedStains[0][1] > 0.7 ? 'High confidence identification' : sortedStains[0][1] > 0.5 ? 'Moderate confidence - consider additional testing' : 'Low confidence - manual verification recommended'}
            `;

            const blob = new Blob([report], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'RBC_Analysis_Report.txt';
            a.click();
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>
